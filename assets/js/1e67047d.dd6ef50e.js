"use strict";(self.webpackChunktenet_docs=self.webpackChunktenet_docs||[]).push([[865],{3905:(e,t,n)=>{n.d(t,{Zo:()=>d,kt:()=>f});var r=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},i=Object.keys(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var c=r.createContext({}),l=function(e){var t=r.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},d=function(e){var t=l(e.components);return r.createElement(c.Provider,{value:t},e.children)},u="mdxType",p={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},m=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,i=e.originalType,c=e.parentName,d=s(e,["components","mdxType","originalType","parentName"]),u=l(n),m=a,f=u["".concat(c,".").concat(m)]||u[m]||p[m]||i;return n?r.createElement(f,o(o({ref:t},d),{},{components:n})):r.createElement(f,o({ref:t},d))}));function f(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var i=n.length,o=new Array(i);o[0]=m;var s={};for(var c in t)hasOwnProperty.call(t,c)&&(s[c]=t[c]);s.originalType=e,s[u]="string"==typeof e?e:a,o[1]=s;for(var l=2;l<i;l++)o[l]=n[l];return r.createElement.apply(null,o)}return r.createElement.apply(null,n)}m.displayName="MDXCreateElement"},2275:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>o,default:()=>p,frontMatter:()=>i,metadata:()=>s,toc:()=>l});var r=n(7462),a=(n(7294),n(3905));const i={sidebar_position:1},o="Overview",s={unversionedId:"index",id:"index",title:"Overview",description:"The TLSDFactory contract is a Solidity smart contract that facilitates the issuance and management of TLSD",source:"@site/docs/tLSD/index.md",sourceDirName:".",slug:"/",permalink:"/tenet-docs/tLSD/",draft:!1,editUrl:"https://github.com/tenet-org/tenet-docs/edit/master/docs/tLSD/index.md",tags:[],version:"current",sidebarPosition:1,frontMatter:{sidebar_position:1},sidebar:"docsSidebar",next:{title:"TLSDFactory Interface",permalink:"/tenet-docs/tLSD/interface"}},c={},l=[],d={toc:l},u="wrapper";function p(e){let{components:t,...n}=e;return(0,a.kt)(u,(0,r.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"overview"},"Overview"),(0,a.kt)("p",null,"The TLSDFactory contract is a Solidity smart contract that facilitates the issuance and management of TLSD\n(Tenet Liquid Staking Derivative) tokens on the Tenet Blockchain. TLSD tokens represent staked assets by users with\nspecific validators. "),(0,a.kt)("p",null,"The contract allows users to stake ERC20 tokens or native assets (TENET) with validators,\nminting corresponding TLSD tokens based on the amount staked. Users can later burn TLSD tokens to redeem their\nstaked assets. The contract handles delegation, staking, and rewards claiming via interactions with\nprecompiled contracts. It generates unique TLSD tokens for each validator-asset combination, providing a\nmechanism to create and manage TLSDs efficiently."),(0,a.kt)("h1",{id:"interface"},"Interface"),(0,a.kt)("p",null,"The contract contains various functions to interact with TLSD tokens and their issuance, burning, delegation, and rewards claiming. Some of the key functions are as follows:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"issue"),": Allows users to issue TLSD tokens by staking a specific asset (ERC20 token) with a validator. The TLSD tokens are minted and issued based on the amount staked."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"issueNative"),": Similar to issue, but for the native asset (ETH) instead of an ERC20 token."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"burn"),": Allows users to burn (redeem) their TLSD tokens and receive the corresponding staked assets back from the validator."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"claimRewards"),": Allows users to claim rewards associated with their staked TLSD tokens."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"getValidator")," and ",(0,a.kt)("inlineCode",{parentName:"li"},"getAsset"),": Helper functions to retrieve the associated validator and asset for a given TLSD token address."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"TLSDToAsset"),": Converts an amount of TLSD tokens to the corresponding amount of staked assets.")))}p.isMDXComponent=!0}}]);